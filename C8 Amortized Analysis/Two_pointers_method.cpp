// ? Summary: Sometimes a straight-forward analysis does not give a true picture of the efficiency of the algorithm 
/* 
feat: Amortized analysis: Analyze algorithms that contain operations whose time complexity varies
    ? The idea is to estimate the !total time! used to all such operations during the execution of the algorithm, instead of focusing on individual operations

*/

/* 
feat: Two pointers method: 
?    Two pointers are used to iterate through the array values, both pointers can move to one direction only, which ensures that the algorithm works efficiently



*/
#include <bits/stdc++.h>
using namespace std; 

static int fast_io=[](){ios::sync_with_stdio(0); cin.tie(nullptr); cout.tie(nullptr); return 0;}();

//Macros
typedef unsigned long long ULL; 
#define REP(i,a,b) for(int i = a; i < b; i++)
typedef long long LL;

//Global variables

//Function 

//Main function 
int main() {
    int arr1[] = {34,32,42,423,5}; 
    
    int n = sizeof(arr1)/ sizeof(arr1[0]); 
    
    cout << n << endl; 
    
    
}